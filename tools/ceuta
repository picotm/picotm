#!/usr/bin/perl

# Copyright (C) 2009  Thomas Zimmermann
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, version 2
# of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

#
# Ceuta - a code generator for taglibc entry points
#
# This program is called 'ceuta', following a local tradition of naming
# software like cities near the Street of Gibraltar. Ceuta generates C files
# or headers with entry points of taglibc actions.
#
# Usage: `ceuta [options] < <inputfile> > <outputfile>'
#   <inputfile>     CU file with declarations
#   <outputfile>    C implementation or header file
# Options:
#   -h              Generate header
#
# The syntax of an input file is as follows:
#
#   Each statement is contained on one line.
#
#   Each line that does not contain a statement is copied to the C implementation.
#
#   Each statement starts with 'ceuta_' and ends with ';'
#
# Available statements:
#
#   ceuta_wrap(<return type>, <interface name>, <execute function>, <arguments>);
#
#       Wraps the execute method of an unprotected or stateful protected
#       action behind a generated entry-point function.
#
#       <return type>       return type of function, e.g., 'ssize_t'
#       <interface name>    The public interface, e.g., 'write'
#       <execute function>  The function to call internally, e.g., 'write_execute'
#       <arguments>         List of arguments, e.g., 'int fd, [siz=nbyte] const char *buf, size_t nbyte'
#
#       The complete example makes 'write_execute' available under the name
#       'write'.
#
#       ceuta_wrap(ssize_t, write, write_execute, int fd, [siz=nbyte|in] const char *buf, size_t size);
#
#       The option in brackets before 'const char *buf' signals the
#       usage of the pointer's data.
#
#       [in]            Value goes in
#
#       [out]           Value comes out
#
#       [siz=<var>]     Size of the pointer's data is <var> (in byte), <var>
#                       can be an argument, a variable name or a fixed value
#
#       [len=<var>]     Length of the pointer's data is <var> (in elements),
#                       <var> can be an argument, a variable name or a fixed
#                       value
#
#       [sizof=<var>]   Size of the pointer's data is the size of <var>, <var>
#                       can be an argument, a variable name or a fixed value
#
#       [cstring]       Pointer refers to a 0-terminated C string
#
#       There is also an option for return values.
#
#       [use=val]       Uses <val> as return value, instead of the execute
#                       function's
#
#       For example
#
#       ceuta_wrap([use=s] void*, memset, memset, [siz=n|out] void *s, int c, size_t n);
#
#       makes memset return the supplied buffer instead of the internal
#       trasaction-safe buffer.
#
#
#   ceuta_excl(<return type>, <interface name>, <execute function>, <arguments>);
#
#       Declares a real (irrevocable) action
#
#       <return type>       return type of function, e.g., 'int'
#       <interface name>    The public interface, e.g., 'dup2'
#       <execute function>  The function to call internally, e.g., also 'dup2'
#       <arguments>         List of arguments, e.g., 'int oldfd, int newfd'
#
#       The complete example makes dup2 available as irrevocable function
#
#       ceuta_excl(int, dup2, dup2, int oldfd, int newfd);
#
#       A call will make the transaction irrevocable and then execute dup2
#       directly.
#
#
#   ceuta_pure(<return type>, <interface name>, <execute function>, <arguments>);
#
#       Declare a stateless protected action.
#
#       ceuta_excl(double, cos, double val);
#
#       The call will make the cosinus function directly available within the
#       transaction
#
#
#   ceuta_decl(<return type>, <interface name>, <execute function>, <arguments>);
#
#       Only generates declaration in the header file. This is useful if
#       implementation needs to be hand crafted.
#
#
#   ceuta_hdrl(...);
#
#       Copy output to generated header file, but not to implementation.
#
#
# Examples of input files are the .cu files in lib/libc. The generator
# should work with many functions, but does not support function pointers
# and multiple indirections, aka pointers to pointers.
#
# The scripts below could easily be one of the most ugliest ever. So be warned.
# There'll be dragons here.
#
#   Thomas
#

use 5.010;
use strict;
use warnings;

use Getopt::Std;

my $header = 0;

my $rvalue;
my $call;
my $target;
my @opts;
my @args;

# return value
my $rvalue_ostr;
my $rvalue_type;

#args
my @arg_ostr;
my @arg_type;
my @arg_astr;
my @arg_name;

my $alloca_limit = 1024;

#
# Generator functions
#

sub find_arg_index
{
    my ($name) = @_;

    for (my $i = 0; $i < @arg_name; ++$i) {
        if ($arg_name[$i] eq $name) {
            return $i;
        }
    }

    return undef;
}

sub find_arg_size
{
    my ($name) = @_;

    my $argi = &find_arg_index($name);

    my %opts = &parse_argument_opts($arg_ostr[$argi]);

    # Has foreign size
    if (exists $opts{"sizof"}) {
        return &find_arg_size($opts{"sizof"});
    }

    my $len;

    if (exists $opts{"cstring"}) {
        $len = "strlen(arg$argi)";
    } elsif (exists $opts{"len"}) {
        $len = exists $opts{"len"};
    } else {
        $len = 1;
    }

    return exists $opts{"siz"} ? $opts{"siz"} : "($len*sizeof($arg_astr[$argi]$name))";
}

sub generate_wrap_arg
{
    my ($var, $type, $astr, $name) = @_;

    my %opts = parse_argument_opts($_[4]);

    unless ($astr) {
        say "    $var = $name;";
        return 1;
    }

    # Length

    my $siz = find_arg_size($name);

    say "    if ($name) {";

    if (exists $opts{"in"}) {

        # Memory is input

	    if (exists $opts{"cstring"}) {
	    	# FIXME: Workaround missing '\0' from load_regionstring
	    	# Doesn't work reliably with strings on heap
	    	say "    {";
	    	say "        unsigned int len=0;";
        	say "        const void *tmp = tanger_stm_loadregionstring(tx, (char*)$name, (uintptr_t*)&len);";
        	say "        heap_alloc_$var = (len+1 > $alloca_limit);";
        	say "        if (heap_alloc_$var) {";
        	say "            $var = com_alloc_tx_malloc(len+1);";
        	say "            if (!$var) {";
        	say "                perror(\"malloc\");";
        	say "                abort();";
        	say "            }";
        	say "        } else {";
        	say "            $var = alloca(len+1);";
        	say "        }";
        	say "        memcpy($var, tmp, len);";
        	say "        ((char*)$var)\[len\] = \'\\0\';";
        	say "        tanger_stm_loadregionpost(tx, (uint8_t*)$name, len);";
	    	say "    }";
	    } else {
        	say "    heap_alloc_$var = ($siz > $alloca_limit);";
        	say "    if (heap_alloc_$var) {";
	    	say "        $var = com_alloc_tx_malloc($siz);";
        	say "        if (!$var) {";
        	say "            perror(\"malloc\");";
        	say "            abort();";
        	say "        }";
            say "    } else {";
        	say "        $var = alloca($siz);";
        	say "    }";
        	say "    tanger_stm_loadregion(tx, (uint8_t*)$name, (uintptr_t)$siz, $var);";
		}
    } elsif (exists $opts{"out"}) {

        # Memory is output
      	say "    heap_alloc_$var = ($siz > $alloca_limit);";
      	say "    if (heap_alloc_$var) {";
    	say "        $var = com_alloc_tx_malloc($siz);";
    	say "        if (!$var) {";
    	say "            perror(\"malloc\");";
    	say "            abort();";
    	say "        }";
    	say "    } else {";
    	say "        $var = alloca($siz);";
    	say "    }";

    } else {

        # Memory is not touched
        say "    $var = $name;";
    }

    say "    } else {";
    say "        $var = NULL;";
    say "    }";

    return 1;
}

sub generate_cleanup_arg
{
    my ($var, $type, $astr, $name) = @_;

    my %opts = parse_argument_opts($_[4]);

    unless ($astr) {
        return 1;
    }

    if (exists $opts{"out"}) {

        # Memory is output

        my $siz = find_arg_size($name);

        say "    if ($name) {";
        say "        tanger_stm_storeregion(tx, (uint8_t*)$var, (uintptr_t)$siz, (uint8_t*)$name);";
        say "        if (heap_alloc_$var && $var) {";
    	say "            com_alloc_tx_free($var);";
        say "        }";
        say "    }";
    } elsif (exists $opts{"in"}) {

        # Memory is input
        say "    if (heap_alloc_$var && $var) {";
    	say "        com_alloc_tx_free($var);";
        say "    }";
    } else {

        # Memory not touched
    }

    return 1;
}

sub get_argument_index
{
    my $name = shift(@_);

    for (my $i = 0; $i < @_; ++$i) {
        if ($_[$i] eq $name) {
            return $i;
        }
    }

    return undef;
}

sub generate_wrap_func
{
    my @ostr;
    my @type;
    my @astr;
    my @name;

    # Parse arguments of format: [ostr] type * name

    for (my $i = 0; $i < @args; ++$i) {

        if ($args[$i] =~ /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w)\s+(?<astr>(\*)*)\s*(?<name>\w+)/ ) {
            $ostr[$i] = $+{ostr};
            $type[$i] = $+{type};
            $astr[$i] = $+{astr};
            $name[$i] = $+{name};
        }
    }

    # Generate function header

    print("extern $rvalue_type tanger_stm_std_$call("); # . join(",", @args);

    for (my $i = 0; $i < @args; ++$i) {
        if ($i) {
            print ", $type[$i] $astr[$i] $name[$i]";
        } else {
            print "$type[$i] $astr[$i] $name[$i]";
        }
    }

    say ")";
    say "{";

    for (my $i = 0; $i < @args; ++$i) {
        if ($astr[$i]) {
            say "    void $astr[$i] arg$i;";

            my %opts = &parse_argument_opts($ostr[$i]);

            if ((exists $opts{"in"}) || (exists $opts{"out"})) {
                say "    int heap_alloc_arg$i;";
            }
        } else {
            say "    $type[$i] arg$i;";
        }
    }

    unless ($rvalue_type eq "void") {
        say "    $rvalue_type res;";
    }

    say "    tanger_stm_tx_t *tx = tanger_stm_get_tx();";
    say "    assert(tx);";

    # Reorder arguments for load/store code

    my @order = 0..$#args;

    {
        my $changes = 0;

        do {
            $changes = 0;

            for (my $i = 0; $i < @order; ++$i) {

                my $oi = $order[$i];

                my %opts = &parse_argument_opts($ostr[$oi]);

                if (exists $opts{"sizof"}) {
                    my $j = &get_argument_index($opts{"sizof"}, @name);

                    if ($order[$j] > $order[$i]) {
                        @order[$i, $j] = @order[$j, $i];
                        $changes = 1;
                    }
                }
            }
        } while ($changes);
    }

    # Generate pre-load/-store code

    for (my $i = 0; $i < @args; ++$i) {
        &generate_wrap_arg("arg$order[$i]", $type[$order[$i]],
                                            $astr[$order[$i]],
                                            $name[$order[$i]],
                                            $ostr[$order[$i]]);
    }

    # Generate function call 

    unless ($rvalue_type eq "void") {
        print "    res = $target(";
    } else {
        print "    $target(";
    }

    for (my $i = 0; $i < @args; ++$i) {
        if ($i) {
            print ", arg$i";
        } else {
            print "arg$i";
        }
    }

    say(");");

    # Cleanups and return

    for (my $i = 0; $i < @args; ++$i) {
        &generate_cleanup_arg("arg$order[$i]", $type[$order[$i]],
                                               $astr[$order[$i]],
                                               $name[$order[$i]],
                                               $ostr[$order[$i]]);
    }

    unless ($rvalue_type eq "void") {
        if ($rvalue_ostr) {
            $_ = $rvalue_ostr;
            if (( /\[\s*(?<opt>\w+)\s*=\s*(?<val>\w+)\s*\]/)
                && ($+{opt} eq "use")) {
                say   "    return ($rvalue_type) $+{val};";
            } else {
                say "    return res;";
            }
        } else {
            say "    return res;";
        }
    }

    say "}";

    return 1;
}

sub generate_wrap_decl
{
    my @ostr;
    my @type;
    my @astr;
    my @name;

    # Parse arguments of format: [ostr] type * name

    for (my $i = 0; $i < @args; ++$i) {

        if ($args[$i] =~ /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w)\s+(?<astr>(\*)*)\s*(?<name>\w+)/ ) {
            $ostr[$i] = $+{ostr};
            $type[$i] = $+{type};
            $astr[$i] = $+{astr};
            $name[$i] = $+{name};
        }
    }

    # Generate function header

    print("static $rvalue_type tanger_wrapper_tanger_stm_std_$call("); # . join(",", @args);

    if (@args) {
        for (my $i = 0; $i < @args; ++$i) {
            if ($i) {
                print ", $type[$i] $astr[$i] $name[$i]";
            } else {
                print "$type[$i] $astr[$i] $name[$i]";
            }
        }
    } else {
        print "void";
    }

    say ") __attribute__ ((weakref(\"$call\")));";

    return 1;
}

#
# Exclusive-function generator
#

sub generate_excl_func
{
    my @ostr;
    my @type;
    my @astr;
    my @name;

    # Parse arguments of format: [ostr] type * name

    for (my $i = 0; $i < @args; ++$i) {

        if ($args[$i] =~ /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w)\s+(?<astr>(\*)*)\s*(?<name>\w+)/ ) {
            $ostr[$i] = $+{ostr};
            $type[$i] = $+{type};
            $astr[$i] = $+{astr};
            $name[$i] = $+{name};
        }
    }

    # Generate function head

    print("extern $rvalue_type tanger_stm_std_$call("); # . join(",", @args);

    for (my $i = 0; $i < @args; ++$i) {
        if ($i) {
            print ", $type[$i] $astr[$i] $name[$i]";
        } else {
            print "$type[$i] $astr[$i] $name[$i]";
        }
    }

    say ")";
    say "{";

    # Generate irrevokability switch

    say "    tanger_stm_tx_t *tx;";
    say "    enum error_code err;";

    say "    tx = tanger_stm_get_tx();";
    say "    assert(tx);";
    say "    if ( (err = tanger_stm_go_noundo(tx)) ) {";
    say "        if (err == ERR_CONFLICT) {";
    say "            tanger_stm_abort_self(tx);";
    say "        } else {";
    say "            abort();";
    say "        }";
    say "    }";

    # Generate function call 

    unless ($rvalue_type eq "void") {
        print "    return $target(";
    } else {
        print "    $target(";
    }

    for (my $i = 0; $i < @args; ++$i) {
        if ($i) {
            print ", $name[$i]";
        } else {
            print "$name[$i]";
        }
    }

    say(");");

    # Return

    say "}";

    return 1;
}

sub generate_excl_decl
{
    my @ostr;
    my @type;
    my @astr;
    my @name;

    # Parse arguments of format: [ostr] type * name

    for (my $i = 0; $i < @args; ++$i) {

        if ($args[$i] =~ /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w)\s+(?<astr>(\*)*)\s*(?<name>\w+)/ ) {
            $ostr[$i] = $+{ostr};
            $type[$i] = $+{type};
            $astr[$i] = $+{astr};
            $name[$i] = $+{name};
        }
    }

    # Generate function header

    print("static $rvalue_type tanger_wrapper_tanger_stm_std_$call("); # . join(",", @args);

    if (@args) {
        for (my $i = 0; $i < @args; ++$i) {
            if ($i) {
                print ", $type[$i] $astr[$i] $name[$i]";
            } else {
                print "$type[$i] $astr[$i] $name[$i]";
            }
        }
    } else {
        print "void";
    }

    say ") __attribute__ ((weakref(\"$call\")));";

    return 1;
}

#
# Pure-function generator
#

sub generate_pure_decl
{
    my @ostr;
    my @type;
    my @astr;
    my @name;

    # Parse arguments of format: [ostr] type * name

    for (my $i = 0; $i < @args; ++$i) {

        if ($args[$i] =~ /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w)\s+(?<astr>(\*)*)\s*(?<name>\w+)/ ) {
            $ostr[$i] = $+{ostr};
            $type[$i] = $+{type};
            $astr[$i] = $+{astr};
            $name[$i] = $+{name};
        }
    }

    # Generate function header

    print("static $rvalue_type tanger_wrapperpure_tanger_stm_std_$call("); # . join(",", @args);

    if (@args) {
        for (my $i = 0; $i < @args; ++$i) {
            if ($i) {
                print ", $type[$i] $astr[$i] $name[$i]";
            } else {
                print "$type[$i] $astr[$i] $name[$i]";
            }
        }
    } else {
        print "void";
    }

    say ") __attribute__ ((weakref(\"$call\")));";

    return 1;
}

#
# Parser functions
#

sub parse_argument_opts
{
    my %opts;

    foreach ( split /\[|\||\]/, $_[0] ) {
        if ( /\s*(?<key>\w+)\s*=\s*(?<value>\**\w+)\s*/ ) {
            $opts{$+{key}} = $+{value}; # Set key-value pair
        } else {
            $opts{$_} = 1; # Insert value
        }
    }

    return %opts;
}

sub parse_stmt_component
{
    my @comp;

    if ($_[0] =~ /^\s*(.*\S)\s*$/ ) {
        push(@comp, $1);
    }

    return @comp;
}

sub parse_stmt_components
{
    my @components;

    foreach (split /,/, $_[0]) {

        # Remove leading and trailing whitespaces
        if ( /^\s*(.*\S)\s*$/ ) {
            push(@components, $1);
        }
    }

    return @components;
}

sub parse_stmt_params
{
    my @components = &parse_stmt_components($_[0]);

    if (@components < 3) {
        return 0;
    }

    $rvalue = shift(@components);
    $call = shift(@components);
    $target = shift(@components);
    @args = @components;
    @arg_ostr = ();
    @arg_type = ();
    @arg_astr = ();
    @arg_name = ();

    # Parse return value

#    $rvalue_type = $rvalue;

    $_ = $rvalue;

#    if ( /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w\s+(\*)*)\s*/ ) {
    if ( /\s*(?<ostr>(\[.*\])?)\s*(?<type>(\w)*\w\s*\**)\s*/ ) {
        $rvalue_ostr = $+{ostr};
        $rvalue_type = $+{type};
    }

#    say "$rvalue_ostr";
#    say "$rvalue_type";

    # Parse arguments

    foreach (@args) {
        if ( /(?<ostr>(\[.*\])?)\s*(?<type>(\s|\w)*\w)\s+(?<astr>(\*)*)\s*(?<name>\w+)/ ) {
            push(@arg_ostr, $+{ostr});
            push(@arg_type, $+{type});
            push(@arg_astr, $+{astr});
            push(@arg_name, $+{name});
        }
    }

    return 1;
}

sub parse_pure_stmt
{
    return !$header ||
           (&parse_stmt_params(@_) && &generate_pure_decl);

    return 1;
}

sub parse_decl_stmt
{
    return &parse_stmt_params(@_) &&
           $header ? &generate_wrap_decl : 1;
}

sub parse_wrap_stmt
{
    return &parse_stmt_params(@_) &&
           $header ? &generate_wrap_decl : &generate_wrap_func;
}

sub parse_excl_stmt
{
    return &parse_stmt_params(@_) &&
           $header ? &generate_excl_decl : &generate_excl_func;
}

sub parse_hdlr_stmt
{
    if ($header) {
	    say "@_";
    }

	return 1;
}

sub parse_stmt
{
    my ($stmt) = @_;

    if ($stmt =~ /ceuta_pure\s*\(\s*(.*)\s*\)/ ) {
        return &parse_pure_stmt($1);
    } elsif ($stmt =~ /ceuta_decl\s*\(\s*(.*)\s*\)/ ) {
        return &parse_decl_stmt($1);
    } elsif ( /ceuta_wrap\s*\(\s*(.*)\s*\)/ ) {
        return &parse_wrap_stmt($1);
    } elsif ( /ceuta_excl\s*\(\s*(.*)\s*\)/ ) {
        return &parse_excl_stmt($1);
    } elsif ($stmt =~ /ceuta_hdrl\s*\(\s*(.*)\s*\)/ ) {
        return &parse_hdlr_stmt($1);
	}

    return 0;
}

# Main

my %options = ();
getopts("h", \%options);

$header = 1 if defined $options{h};

if ($header) {
    say "#ifdef __cplusplus";
    say "extern \"C\" {";
    say "#endif";
} else {
    say "#include <assert.h>";
    say "#include <stdio.h>";
    say "#include <stdlib.h>";
    say "#include <string.h>"; # Needed for strlen
    say "#include <tanger-stm-internal.h>";
    say "#include <tanger-stm-internal-errcode.h>";
    say "#include <tanger-stm-internal-extact.h>";
    say "extern void* com_alloc_tx_malloc(size_t);";
    say "extern void  com_alloc_tx_free(void*);";
}

while (<>) {
    chomp;
    unless ((/^\s*(.*)\s*;\s*$/) && &parse_stmt($1) || $header) {
        say;
    }
}

if ($header) {
    say "#ifdef __cplusplus";
    say "}";
    say "#endif";
}

say "";

